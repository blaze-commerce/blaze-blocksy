name: Semantic Release

on:
  pull_request:
    types: [closed]
    branches:
      - main
      - master
      # Note: This workflow will skip execution for automated version bump PRs
      # to prevent cascading releases (version bump PRs have branch pattern 'release/bump-v*')

jobs:
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.merged == true &&
      !startsWith(github.event.pull_request.head.ref, 'release/bump-v') &&
      !startsWith(github.event.pull_request.title, 'chore(release): bump theme version to')

    permissions:
      contents: write
      issues: write
      pull-requests: write

    outputs:
      new-release-version: ${{ steps.new-version.outputs.new-version }}
      
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.BLAZECOMMERCE_BOT_APP_ID }}
          private-key: ${{ secrets.BLAZECOMMERCE_BOT_PRIVATE_KEY }}

      - name: Validate merge commit SHA
        run: |
          if [ -z "${{ github.event.pull_request.merge_commit_sha }}" ]; then
            echo "Error: merge_commit_sha is empty"
            exit 1
          fi
          echo "Merge commit SHA: ${{ github.event.pull_request.merge_commit_sha }}"

      - name: Checkout repository at merge commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.merge_commit_sha }}
          token: ${{ steps.app-token.outputs.token }}

      - name: Check if changes are non-functional
        id: check-non-functional
        run: |
          # Get the list of changed files in this PR
          CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path')
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Define patterns for non-functional files that should not trigger releases
          NON_FUNCTIONAL_PATTERNS=(
            # Documentation files
            "^README\.md$"
            "^CHANGELOG\.md$"
            "^LICENSE$"
            "^COPYING$"
            "\.md$"
            "^docs/"

            # Development configuration files
            "^\.gitignore$"
            "^\.gitattributes$"
            "^\.editorconfig$"
            "^\.augmentignore$"
            "^\.augment/"

            # CI/CD configuration (unless changing core functionality)
            "^\.github/workflows/"
            "^\.github/ISSUE_TEMPLATE/"
            "^\.github/PULL_REQUEST_TEMPLATE"

            # IDE and editor files
            "^\.vscode/"
            "^\.idea/"
            "\.swp$"
            "\.swo$"
            "\.tmp$"

            # Test files
            "^test/"
            "^tests/"
            "^spec/"
            "^__tests__/"
            "\.test\."
            "\.spec\."

            # Build artifacts and dependencies
            "^dist/"
            "^build/"
            "^node_modules/"
            "^vendor/"
            "^coverage/"
            "\.log$"
            "\.cache$"

            # Media assets (unless functional)
            "^screenshot\.(jpg|jpeg|png|gif|webp)$"
            "^assets/.*\.(jpg|jpeg|png|gif|webp|svg)$"
          )

          # Check if all changes are non-functional
          NON_FUNCTIONAL_ONLY=true
          while IFS= read -r file; do
            if [[ -n "$file" ]]; then
              IS_NON_FUNCTIONAL=false
              for pattern in "${NON_FUNCTIONAL_PATTERNS[@]}"; do
                if [[ "$file" =~ $pattern ]]; then
                  echo "Non-functional file: $file (matches pattern: $pattern)"
                  IS_NON_FUNCTIONAL=true
                  break
                fi
              done

              if [[ "$IS_NON_FUNCTIONAL" == "false" ]]; then
                # Special case: check if style.css only has version changes
                if [[ "$file" == "style.css" ]]; then
                  git diff HEAD~1 HEAD -- style.css | grep -E "^\+" | grep -v "^\+\+\+" | grep -qE "Version: [0-9]+\.[0-9]+\.[0-9]+"
                  if [[ $? -eq 0 ]] && [[ $(git diff HEAD~1 HEAD -- style.css | grep -E "^\+" | grep -v "^\+\+\+" | wc -l) -eq 1 ]]; then
                    echo "Only version number changed in style.css"
                    IS_NON_FUNCTIONAL=true
                  fi
                fi

                if [[ "$IS_NON_FUNCTIONAL" == "false" ]]; then
                  echo "Found functional file: $file"
                  NON_FUNCTIONAL_ONLY=false
                  break
                fi
              fi
            fi
          done <<< "$CHANGED_FILES"

          echo "non-functional-only=${NON_FUNCTIONAL_ONLY}" >> $GITHUB_OUTPUT
          echo "Non-functional-only changes: ${NON_FUNCTIONAL_ONLY}"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y rsync zip
          
      - name: Configure Git
        run: |
          git config --global user.name "BlazeCommerce Automation Bot"
          git config --global user.email "automation@blazecommerce.io"
          git remote set-url origin https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${{ github.repository }}.git
          
      - name: Skip release for non-functional changes
        if: steps.check-non-functional.outputs.non-functional-only == 'true'
        run: |
          echo "‚è≠Ô∏è Skipping release - changes are non-functional (documentation/tooling/config updates)"
          echo "Changed files contain only:"
          echo "- Documentation files (*.md, docs/, LICENSE)"
          echo "- Development configuration (.gitignore, .editorconfig, etc.)"
          echo "- CI/CD configuration files"
          echo "- IDE/editor files"
          echo "- Test files"
          echo "- Build artifacts"
          echo "- Media assets"
          echo "- Augment tooling files (.augmentignore, .augment/)"
          echo "- CSS version number updates"
          echo "No functional changes detected - release not needed"
          exit 0

      - name: Validate CHANGELOG.md format
        id: validate-changelog
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          echo "Validating CHANGELOG.md format compliance..."

          # Check if CHANGELOG.md exists
          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "‚ùå Error: CHANGELOG.md not found"
            echo "Please create a CHANGELOG.md file following Keep a Changelog format"
            exit 1
          fi

          # Validate required sections and format
          VALIDATION_ERRORS=()

          # Check for proper header
          if ! grep -q "# Changelog" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing '# Changelog' header")
          fi

          # Check for Keep a Changelog reference
          if ! grep -q "keepachangelog.com" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing Keep a Changelog reference")
          fi

          # Check for [Unreleased] section
          if ! grep -q "## \[Unreleased\]" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing [Unreleased] section")
          fi

          # Check for semantic versioning reference
          if ! grep -q "semver.org" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing Semantic Versioning reference")
          fi

          # Check for version links at bottom
          if ! grep -q "\[unreleased\]:" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing version comparison links")
          fi

          # Report validation results
          if [[ ${#VALIDATION_ERRORS[@]} -gt 0 ]]; then
            echo "‚ùå CHANGELOG.md validation failed:"
            for error in "${VALIDATION_ERRORS[@]}"; do
              echo "  - $error"
            done
            echo ""
            echo "Please ensure CHANGELOG.md follows Keep a Changelog v1.1.0 format:"
            echo "https://keepachangelog.com/en/1.1.0/"
            exit 1
          fi

          echo "‚úÖ CHANGELOG.md format validation passed"

      - name: Get current version from style.css
        id: current-version
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          if grep -q "Version:" style.css; then
            CURRENT_VERSION=$(grep "Version:" style.css | sed 's/.*Version: *\([0-9.]*\).*/\1/')
            echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          else
            echo "current-version=0.0.0" >> $GITHUB_OUTPUT
          fi
          
      - name: Determine version bump
        id: version-bump
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          # Get commits since last tag or from beginning if no tags
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s" --no-merges)
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          fi
          
          echo "Analyzing commits:"
          echo "$COMMITS"
          
          # Determine bump type
          BUMP_TYPE="patch"
          
          if echo "$COMMITS" | grep -qE "^(feat!|fix!|BREAKING CHANGE)" || echo "$COMMITS" | grep -q "BREAKING CHANGE:"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
            BUMP_TYPE="minor"
          elif echo "$COMMITS" | grep -qE "^fix(\(.+\))?:"; then
            BUMP_TYPE="patch"
          fi
          
          echo "bump-type=${BUMP_TYPE}" >> $GITHUB_OUTPUT
          echo "Determined bump type: ${BUMP_TYPE}"
          
      - name: Calculate new version
        id: new-version
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current-version }}"
          BUMP_TYPE="${{ steps.version-bump.outputs.bump-type }}"
          
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "new-version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "New version: ${NEW_VERSION}"
          
      - name: Update version in style.css
        id: update-version
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          NEW_VERSION="${{ steps.new-version.outputs.new-version }}"

          # Validate version format
          if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Error: Invalid version format: $NEW_VERSION"
            exit 1
          fi

          # Escape version for sed (handle special characters)
          ESCAPED_VERSION=$(printf '%s\n' "$NEW_VERSION" | sed 's/[[\.*^$()+?{|]/\\&/g')

          # Check if Version field exists
          if grep -q "Version:" style.css; then
            # Update existing version
            sed -i "s/Version: *[0-9.]*/Version: ${ESCAPED_VERSION}/" style.css
            echo "Updated existing version to ${NEW_VERSION}"
          else
            # Add version after Template line or at end of header
            if grep -q "Template:" style.css; then
              sed -i "/Template:/a \ * Version: ${ESCAPED_VERSION}" style.css
            else
              sed -i "/Text Domain:/a \ * Version: ${ESCAPED_VERSION}" style.css
            fi
            echo "Added new version ${NEW_VERSION}"
          fi

          # Verify the change
          echo "Updated style.css header:"
          head -10 style.css

          # Validate the update worked
          if ! grep -q "Version: ${NEW_VERSION}" style.css; then
            echo "Error: Version update failed"
            exit 1
          fi
          
      - name: Update CHANGELOG.md
        id: update-changelog
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          NEW_VERSION="${{ steps.new-version.outputs.new-version }}"
          CURRENT_DATE=$(date +%Y-%m-%d)

          # Validate CHANGELOG.md exists and has proper format
          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "Error: CHANGELOG.md not found"
            exit 1
          fi

          # Check if CHANGELOG.md has [Unreleased] section
          if ! grep -q "## \[Unreleased\]" CHANGELOG.md; then
            echo "Error: CHANGELOG.md missing [Unreleased] section"
            exit 1
          fi

          # Get commits since last tag for changelog
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges)
            COMPARE_URL="commits/v${NEW_VERSION}"
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
            COMPARE_URL="compare/${LAST_TAG}...v${NEW_VERSION}"
          fi

          # Create temporary changelog content for release
          RELEASE_CHANGELOG="## What's Changed\n\n${COMMITS}\n\n**Full Changelog**: https://github.com/${{ github.repository }}/${COMPARE_URL}"
          echo -e "$RELEASE_CHANGELOG" > RELEASE_CHANGELOG.md

          # Update CHANGELOG.md: move Unreleased to new version
          # Create backup
          cp CHANGELOG.md CHANGELOG.md.bak

          # Replace [Unreleased] with new version and add new [Unreleased] section
          python3 -c "
          import re
          with open('CHANGELOG.md', 'r') as f:
              content = f.read()
          new_version = '${NEW_VERSION}'
          current_date = '${CURRENT_DATE}'
          pattern = r'## \[Unreleased\]'
          replacement = f'## [Unreleased]\n\n## [{new_version}] - {current_date}'
          content = re.sub(pattern, replacement, content, count=1)
          with open('CHANGELOG.md', 'w') as f:
              f.write(content)
          print(f'Updated CHANGELOG.md with version {new_version}')
          "

          # Update version links at bottom of changelog
          if grep -q "\\[unreleased\\]:" CHANGELOG.md; then
            # Update existing unreleased link and add new version link
            sed -i "s|\\[unreleased\\]:.*|[unreleased]: https://github.com/${{ github.repository }}/compare/v${NEW_VERSION}...HEAD|" CHANGELOG.md

            # Add new version link before the unreleased link
            sed -i "/\\[unreleased\\]:/i [${NEW_VERSION}]: https://github.com/${{ github.repository }}/compare/${LAST_TAG:-v1.0.0}...v${NEW_VERSION}" CHANGELOG.md
          fi

          echo "Updated CHANGELOG.md for version ${NEW_VERSION}"
          
      - name: Create version bump branch
        id: create-bump-branch
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        env:
          NEW_VERSION: ${{ steps.new-version.outputs.new-version }}
          BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
        run: |
          set -e
          # Escape version for safe use in branch name and commit message
          SAFE_VERSION=$(printf '%q' "${NEW_VERSION}")
          BRANCH="release/bump-v${NEW_VERSION}"

          # Check if branch already exists and delete it
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            echo "Branch $BRANCH already exists, deleting it"
            git push origin --delete "$BRANCH" || true
          fi

          # Delete local branch if it exists
          git branch -D "$BRANCH" 2>/dev/null || true

          git checkout -b "$BRANCH"
          git add style.css CHANGELOG.md
          git commit -m "chore(release): bump theme version to ${SAFE_VERSION}"
          git push --set-upstream origin "$BRANCH"

          echo "branch-name=${BRANCH}" >> $GITHUB_OUTPUT

      - name: Open PR for version bump
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const branch = '${{ steps.create-bump-branch.outputs.branch-name }}';
            const base = '${{ github.event.pull_request.base.ref }}';
            const title = `chore(release): bump theme version to ${{ steps.new-version.outputs.new-version }}`;
            const body = `Automated post-release version bump to keep style.css and CHANGELOG.md in sync with the latest release.\n\nThis PR was created by the release workflow after PR #${{ github.event.pull_request.number }} was approved and merged.\n\n### Changes:\n- Updated style.css version to ${{ steps.new-version.outputs.new-version }}\n- Updated CHANGELOG.md with release information`;

            // Check if a PR already exists
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open'
            });
            if (prs.length > 0) {
              core.info(`PR already exists: #${prs[0].number}`);
              return;
            }
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: branch,
              base: base,
              title,
              body,
              maintainer_can_modify: true
            });
            core.info(`Opened PR #${pr.number} for version bump`);
          
      - name: Create Git tag from version bump commit
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          git fetch --tags
          # Tag the version bump commit (current HEAD) instead of merge commit
          # This ensures the tagged commit contains the version update
          NEW_VERSION="${{ steps.new-version.outputs.new-version }}"
          SAFE_VERSION=$(printf '%q' "${NEW_VERSION}")

          git tag -a "v${NEW_VERSION}" -m "Release v${SAFE_VERSION}" HEAD
          git push origin "v${NEW_VERSION}"

          echo "Tagged commit $(git rev-parse HEAD) as v${NEW_VERSION}"
          
      - name: Create theme ZIP
        id: create-zip
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          ZIP_NAME="blocksy-child-v${{ steps.new-version.outputs.new-version }}.zip"
          THEME_FOLDER="blocksy-child"

          # Clean up any backup files created during the release process
          rm -f *.bak *.backup *.old CHANGELOG.md.bak 2>/dev/null || true

          # Create temporary directory structure for consistent folder naming
          mkdir -p "temp-build/${THEME_FOLDER}"

          # Copy theme files (exclude dev, CI, and build files; include only what WP needs)
          rsync -av --delete \
            --exclude='.git/' \
            --exclude='.github/' \
            --exclude='.augment/' \
            --exclude='.augmentignore' \
            --exclude='.gitignore' \
            --exclude='.gitattributes' \
            --exclude='docs/' \
            --exclude='tests/' \
            --exclude='node_modules/' \
            --exclude='vendor/' \
            --exclude='dist/' \
            --exclude='build/' \
            --exclude='assets/dist/' \
            --exclude='assets/build/' \
            --exclude='src/' \
            --exclude='*.map' \
            --exclude='*.log' \
            --exclude='*.lock' \
            --exclude='*.bak' \
            --exclude='*.backup' \
            --exclude='*.old' \
            --exclude='.env*' \
            --exclude='.vscode/' \
            --exclude='.idea/' \
            --exclude='temp-build/' \
            --exclude='*.md' \
            --exclude='.DS_Store' \
            --exclude='Thumbs.db' \
            . "temp-build/${THEME_FOLDER}/"

          # Create ZIP from temp-build directory (includes the theme folder)
          cd temp-build
          zip -r "../${ZIP_NAME}" "${THEME_FOLDER}"
          cd ..

          # Clean up
          rm -rf temp-build

          echo "zip-name=${ZIP_NAME}" >> $GITHUB_OUTPUT
          echo "Created ZIP: ${ZIP_NAME}"
          echo "Theme folder in ZIP: ${THEME_FOLDER}"
          
      - name: Create GitHub Release
        id: create_release
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        with:
          tag_name: v${{ steps.new-version.outputs.new-version }}
          release_name: Release v${{ steps.new-version.outputs.new-version }}
          body_path: RELEASE_CHANGELOG.md
          draft: false
          prerelease: false
          
      - name: Upload ZIP to Release
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./${{ steps.create-zip.outputs.zip-name }}
          asset_name: ${{ steps.create-zip.outputs.zip-name }}
          asset_content_type: application/zip
          
      - name: Notify on success
        if: success()
        run: |
          echo "‚úÖ Successfully released version ${{ steps.new-version.outputs.new-version }}"
          echo "üì¶ ZIP file: ${{ steps.create-zip.outputs.zip-name }}"
          echo "üîó Release URL: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.new-version.outputs.new-version }}"
          
      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Release workflow failed"
          echo "Please check the logs and fix any issues"
          exit 1

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: release
    if: failure() && needs.release.outputs.new-release-version != ''

    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.BLAZECOMMERCE_BOT_APP_ID }}
          private-key: ${{ secrets.BLAZECOMMERCE_BOT_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Configure Git
        run: |
          git config --global user.name "BlazeCommerce Automation Bot"
          git config --global user.email "automation@blazecommerce.io"
          git remote set-url origin https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${{ github.repository }}.git

      - name: Rollback tag
        run: |
          VERSION="${{ needs.release.outputs.new-release-version }}"
          if [ ! -z "$VERSION" ]; then
            echo "Rolling back version $VERSION"

            # Delete the tag if it exists
            if git tag -l | grep -q "v${VERSION}"; then
              git tag -d "v${VERSION}" || true
              git push --delete origin "v${VERSION}" || true
            fi

            echo "Rollback completed"
          fi
