name: Semantic Release

on:
  pull_request:
    types: [closed]
    branches:
      - main
      - master
      # Note: This workflow will skip execution for automated version bump PRs
      # to prevent cascading releases (version bump PRs have branch pattern 'release/bump-v*')

jobs:
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.merged == true &&
      !startsWith(github.event.pull_request.head.ref, 'release/bump-v') &&
      !startsWith(github.event.pull_request.title, 'chore(release): bump theme version to')

    permissions:
      contents: write
      issues: write
      pull-requests: write

    outputs:
      new-release-version: ${{ steps.new-version.outputs.new-version }}
      
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        continue-on-error: true
        with:
          app-id: ${{ secrets.BLAZECOMMERCE_BOT_APP_ID }}
          private-key: ${{ secrets.BLAZECOMMERCE_BOT_PRIVATE_KEY }}

      - name: Fallback to GITHUB_TOKEN if App Token fails
        id: token-fallback
        run: |
          if [ "${{ steps.app-token.outcome }}" = "failure" ]; then
            echo "⚠️ GitHub App token generation failed, falling back to GITHUB_TOKEN"
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "using-fallback=true" >> $GITHUB_OUTPUT
          else
            echo "✅ GitHub App token generated successfully"
            echo "token=${{ steps.app-token.outputs.token }}" >> $GITHUB_OUTPUT
            echo "using-fallback=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate merge commit SHA
        run: |
          if [ -z "${{ github.event.pull_request.merge_commit_sha }}" ]; then
            echo "Error: merge_commit_sha is empty"
            exit 1
          fi
          echo "Merge commit SHA: ${{ github.event.pull_request.merge_commit_sha }}"

      - name: Checkout repository at merge commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.merge_commit_sha }}
          token: ${{ steps.token-fallback.outputs.token }}

      - name: Check if changes are non-functional
        id: check-non-functional
        run: |
          # Get the list of changed files in this PR
          CHANGED_FILES=$(gh pr view ${{ github.event.pull_request.number }} --json files --jq '.files[].path')
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Define patterns for non-functional files that should not trigger releases
          NON_FUNCTIONAL_PATTERNS=(
            # Documentation files
            "^README\.md$"
            "^CHANGELOG\.md$"
            "^LICENSE$"
            "^COPYING$"
            "\.md$"
            "^docs/"

            # Development configuration files
            "^\.gitignore$"
            "^\.gitattributes$"
            "^\.editorconfig$"
            "^\.augmentignore$"
            "^\.augment/"

            # CI/CD configuration (unless changing core functionality)
            "^\.github/workflows/"
            "^\.github/ISSUE_TEMPLATE/"
            "^\.github/PULL_REQUEST_TEMPLATE"

            # IDE and editor files
            "^\.vscode/"
            "^\.idea/"
            "\.swp$"
            "\.swo$"
            "\.tmp$"

            # Test files
            "^test/"
            "^tests/"
            "^spec/"
            "^__tests__/"
            "\.test\."
            "\.spec\."

            # Build artifacts and dependencies
            "^dist/"
            "^build/"
            "^node_modules/"
            "^vendor/"
            "^coverage/"
            "\.log$"
            "\.cache$"

            # Media assets (unless functional)
            "^screenshot\.(jpg|jpeg|png|gif|webp)$"
            "^assets/.*\.(jpg|jpeg|png|gif|webp|svg)$"
          )

          # Check if all changes are non-functional
          NON_FUNCTIONAL_ONLY=true
          while IFS= read -r file; do
            if [[ -n "$file" ]]; then
              IS_NON_FUNCTIONAL=false
              for pattern in "${NON_FUNCTIONAL_PATTERNS[@]}"; do
                if [[ "$file" =~ $pattern ]]; then
                  echo "Non-functional file: $file (matches pattern: $pattern)"
                  IS_NON_FUNCTIONAL=true
                  break
                fi
              done

              if [[ "$IS_NON_FUNCTIONAL" == "false" ]]; then
                # Special case: check if style.css only has version changes
                if [[ "$file" == "style.css" ]]; then
                  git diff HEAD~1 HEAD -- style.css | grep -E "^\+" | grep -v "^\+\+\+" | grep -qE "Version: [0-9]+\.[0-9]+\.[0-9]+"
                  if [[ $? -eq 0 ]] && [[ $(git diff HEAD~1 HEAD -- style.css | grep -E "^\+" | grep -v "^\+\+\+" | wc -l) -eq 1 ]]; then
                    echo "Only version number changed in style.css"
                    IS_NON_FUNCTIONAL=true
                  fi
                fi

                if [[ "$IS_NON_FUNCTIONAL" == "false" ]]; then
                  echo "Found functional file: $file"
                  NON_FUNCTIONAL_ONLY=false
                  break
                fi
              fi
            fi
          done <<< "$CHANGED_FILES"

          echo "non-functional-only=${NON_FUNCTIONAL_ONLY}" >> $GITHUB_OUTPUT
          echo "Non-functional-only changes: ${NON_FUNCTIONAL_ONLY}"
        env:
          GH_TOKEN: ${{ steps.token-fallback.outputs.token }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y rsync zip
          
      - name: Configure Git
        run: |
          git config --global user.name "BlazeCommerce Automation Bot"
          git config --global user.email "automation@blazecommerce.io"
          git remote set-url origin https://x-access-token:${{ steps.token-fallback.outputs.token }}@github.com/${{ github.repository }}.git
          
      - name: Skip release for non-functional changes
        if: steps.check-non-functional.outputs.non-functional-only == 'true'
        run: |
          echo "⏭️ Skipping release - changes are non-functional (documentation/tooling/config updates)"
          echo "Changed files contain only:"
          echo "- Documentation files (*.md, docs/, LICENSE)"
          echo "- Development configuration (.gitignore, .editorconfig, etc.)"
          echo "- CI/CD configuration files"
          echo "- IDE/editor files"
          echo "- Test files"
          echo "- Build artifacts"
          echo "- Media assets"
          echo "- Augment tooling files (.augmentignore, .augment/)"
          echo "- CSS version number updates"
          echo "No functional changes detected - release not needed"
          exit 0

      - name: Validate CHANGELOG.md format
        id: validate-changelog
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          echo "Validating CHANGELOG.md format compliance..."

          # Check if CHANGELOG.md exists
          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "❌ Error: CHANGELOG.md not found"
            echo "Please create a CHANGELOG.md file following Keep a Changelog format"
            exit 1
          fi

          # Validate required sections and format
          VALIDATION_ERRORS=()

          # Check for proper header
          if ! grep -q "# Changelog" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing '# Changelog' header")
          fi

          # Check for Keep a Changelog reference
          if ! grep -q "keepachangelog.com" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing Keep a Changelog reference")
          fi

          # Check for [Unreleased] section
          if ! grep -q "## \[Unreleased\]" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing [Unreleased] section")
          fi

          # Check for semantic versioning reference
          if ! grep -q "semver.org" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing Semantic Versioning reference")
          fi

          # Check for version links at bottom
          if ! grep -q "\[unreleased\]:" CHANGELOG.md; then
            VALIDATION_ERRORS+=("Missing version comparison links")
          fi

          # Report validation results
          if [[ ${#VALIDATION_ERRORS[@]} -gt 0 ]]; then
            echo "❌ CHANGELOG.md validation failed:"
            for error in "${VALIDATION_ERRORS[@]}"; do
              echo "  - $error"
            done
            echo ""
            echo "Please ensure CHANGELOG.md follows Keep a Changelog v1.1.0 format:"
            echo "https://keepachangelog.com/en/1.1.0/"
            exit 1
          fi

          echo "✅ CHANGELOG.md format validation passed"

      - name: Get current version from style.css
        id: current-version
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          if grep -q "Version:" style.css; then
            CURRENT_VERSION=$(grep "Version:" style.css | sed 's/.*Version: *\([0-9\.]*\).*/\1/')
            echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          else
            echo "current-version=0.0.0" >> $GITHUB_OUTPUT
          fi

      - name: Determine version bump
        id: version-bump
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          # Get commits since last tag or from beginning if no tags
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s" --no-merges)
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          fi

          echo "Analyzing commits:"
          echo "$COMMITS"

          # Determine bump type
          BUMP_TYPE="patch"

          if echo "$COMMITS" | grep -qE "^(feat!|fix!|BREAKING CHANGE)" || echo "$COMMITS" | grep -q "BREAKING CHANGE:"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
            BUMP_TYPE="minor"
          elif echo "$COMMITS" | grep -qE "^fix(\(.+\))?:"; then
            BUMP_TYPE="patch"
          fi

          echo "bump-type=${BUMP_TYPE}" >> $GITHUB_OUTPUT
          echo "Determined bump type: ${BUMP_TYPE}"

      - name: Calculate new version
        id: new-version
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current-version }}"
          BUMP_TYPE="${{ steps.version-bump.outputs.bump-type }}"

          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "new-version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "New version: ${NEW_VERSION}"

      - name: Update version in style.css
        id: update-version
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          NEW_VERSION="${{ steps.new-version.outputs.new-version }}"

          # Validate version format
          if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Error: Invalid version format: $NEW_VERSION"
            exit 1
          fi

          # Escape version for sed (handle special characters)
          ESCAPED_VERSION=$(printf '%s\n' "$NEW_VERSION" | sed 's/[[\.*^$()+?{|]/\\&/g')

          # Check if Version field exists
          if grep -q "Version:" style.css; then
            # Update existing version
            sed -i "s/Version: *[0-9.]*/Version: ${ESCAPED_VERSION}/" style.css
            echo "Updated existing version to ${NEW_VERSION}"
          else
            # Add version after Template line or at end of header
            if grep -q "Template:" style.css; then
              sed -i "/Template:/a \ * Version: ${ESCAPED_VERSION}" style.css
            else
              sed -i "/Text Domain:/a \ * Version: ${ESCAPED_VERSION}" style.css
            fi
            echo "Added new version ${NEW_VERSION}"
          fi

          # Verify the change
          echo "Updated style.css header:"
          head -10 style.css

          # Validate the update worked
          if ! grep -q "Version: ${NEW_VERSION}" style.css; then
            echo "Error: Version update failed"
            exit 1
          fi

      - name: Update CHANGELOG.md
        id: update-changelog
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          NEW_VERSION="${{ steps.new-version.outputs.new-version }}"
          CURRENT_DATE=$(date +%Y-%m-%d)

          # Validate CHANGELOG.md exists and has proper format
          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "Error: CHANGELOG.md not found"
            exit 1
          fi

          # Check if CHANGELOG.md has [Unreleased] section
          if ! grep -q "## \[Unreleased\]" CHANGELOG.md; then
            echo "Error: CHANGELOG.md missing [Unreleased] section"
            exit 1
          fi

          # Get commits since last tag for changelog
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges)
            COMPARE_URL="commits/v${NEW_VERSION}"
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
            COMPARE_URL="compare/${LAST_TAG}...v${NEW_VERSION}"
          fi

          # Create temporary changelog content for release
          RELEASE_CHANGELOG="## What's Changed\n\n${COMMITS}\n\n**Full Changelog**: https://github.com/${{ github.repository }}/${COMPARE_URL}"
          echo -e "$RELEASE_CHANGELOG" > RELEASE_CHANGELOG.md

          # Update CHANGELOG.md: move Unreleased to new version and add new [Unreleased] section
          # Create backup
          cp CHANGELOG.md CHANGELOG.md.bak

          # Replace [Unreleased] with new version and add new [Unreleased] section
          python3 -c "
          import re
          with open('CHANGELOG.md', 'r') as f:
              content = f.read()
          new_version = '${NEW_VERSION}'
          current_date = '${CURRENT_DATE}'
          pattern = r'## \[Unreleased\]'
          replacement = f'## [Unreleased]\n\n## [{new_version}] - {current_date}'
          content = re.sub(pattern, replacement, content, count=1)
          with open('CHANGELOG.md', 'w') as f:
              f.write(content)
          print(f'Updated CHANGELOG.md with version {new_version}')
          "

          # Update version links at bottom of changelog
          if grep -q "\\[unreleased\\]:" CHANGELOG.md; then
            # Update existing unreleased link and add new version link
            sed -i "s|\\[unreleased\\]:.*|[unreleased]: https://github.com/${{ github.repository }}/compare/v${NEW_VERSION}...HEAD|" CHANGELOG.md

            # Add new version link before the unreleased link
            sed -i "/\\[unreleased\\]:/i [${NEW_VERSION}]: https://github.com/${{ github.repository }}/compare/${LAST_TAG:-v1.0.0}...v${NEW_VERSION}" CHANGELOG.md
          fi

          echo "Updated CHANGELOG.md for version ${NEW_VERSION}"

      - name: Create version bump branch
        id: create-bump-branch
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        env:
          NEW_VERSION: ${{ steps.new-version.outputs.new-version }}
          BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
        run: |
          set -e
          # Escape version for safe use in branch name and commit message
          SAFE_VERSION=$(printf '%q' "${NEW_VERSION}")
          BRANCH="release/bump-v${NEW_VERSION}"

          # Check if branch already exists and delete it
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            echo "Branch $BRANCH already exists, deleting it"
            git push origin --delete "$BRANCH" || true
          fi

          # Delete local branch if it exists
          git branch -D "$BRANCH" 2>/dev/null || true

          git checkout -b "$BRANCH"
          git add style.css CHANGELOG.md
          git commit -m "chore(release): bump theme version to ${SAFE_VERSION}"
          git push --set-upstream origin "$BRANCH"

          echo "branch-name=${BRANCH}" >> $GITHUB_OUTPUT

      - name: Open PR for version bump
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.token-fallback.outputs.token }}
          script: |
            const branch = '${{ steps.create-bump-branch.outputs.branch-name }}';
            const base = '${{ github.event.pull_request.base.ref }}';
            const title = `chore(release): bump theme version to ${{ steps.new-version.outputs.new-version }}`;
            const body = `Automated post-release version bump to keep style.css and CHANGELOG.md in sync with the latest release.\n\nThis PR was created by the release workflow after PR #${{ github.event.pull_request.number }} was approved and merged.\n\n### Changes:\n- Updated style.css version to ${{ steps.new-version.outputs.new-version }}\n- Updated CHANGELOG.md with release information`;

            // Check if a PR already exists
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open'
            });
            if (prs.length > 0) {
              core.info(`PR already exists: #${prs[0].number}`);
              return;
            }
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: branch,
              base: base,
              title,
              body,
              maintainer_can_modify: true
            });
            core.info(`Opened PR #${pr.number} for version bump`);

      - name: Create Git tag from version bump commit
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          set -e
          git fetch --tags
          # Tag the version bump commit (current HEAD) instead of merge commit
          # This ensures the tagged commit contains the version update
          NEW_VERSION="${{ steps.new-version.outputs.new-version }}"

          # Input validation for security
          if [ -z "${NEW_VERSION}" ]; then
            echo "❌ Error: NEW_VERSION is empty"
            exit 1
          fi

          # Validate version format to prevent command injection
          if ! echo "${NEW_VERSION}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "❌ Error: Invalid version format: ${NEW_VERSION}"
            echo "Expected format: X.Y.Z (semantic version)"
            exit 1
          fi

          SAFE_VERSION=$(printf '%q' "${NEW_VERSION}")
          echo "🏷️ Processing version: ${NEW_VERSION}"

          # Check if tag already exists and handle it (with proper regex escaping)
          if git tag -l | grep -q "^v${NEW_VERSION}\$"; then
            echo "⚠️ Tag v${NEW_VERSION} already exists. Checking if it points to the same commit..."

            # Get commit hashes with proper error handling
            EXISTING_TAG_COMMIT=$(git rev-list -n 1 "v${NEW_VERSION}" 2>/dev/null || echo "FAILED")
            CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "FAILED")

            # Validate git operations succeeded
            if [ "${EXISTING_TAG_COMMIT}" = "FAILED" ]; then
              echo "❌ Error: Failed to get existing tag commit hash"
              echo "Tag may be corrupted or inaccessible"
              exit 1
            fi

            if [ "${CURRENT_COMMIT}" = "FAILED" ]; then
              echo "❌ Error: Failed to get current commit hash"
              exit 1
            fi

            if [ "${EXISTING_TAG_COMMIT}" = "${CURRENT_COMMIT}" ]; then
              echo "✅ Tag v${NEW_VERSION} already points to current commit ${CURRENT_COMMIT}"
              echo "Skipping tag creation"
            else
              echo "🔄 Tag v${NEW_VERSION} points to different commit ${EXISTING_TAG_COMMIT}, updating it..."
              # Delete existing tag locally and remotely
              git tag -d "v${NEW_VERSION}" || true
              git push --delete origin "v${NEW_VERSION}" || true
              # Create new tag
              git tag -a "v${NEW_VERSION}" -m "Release v${SAFE_VERSION}" HEAD
              git push origin "v${NEW_VERSION}"

              # Verify tag creation succeeded
              FINAL_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "FAILED")
              if [ "${FINAL_COMMIT}" != "FAILED" ]; then
                echo "✅ Updated tag v${NEW_VERSION} to point to commit ${FINAL_COMMIT}"
              else
                echo "⚠️ Tag updated but could not verify final commit"
              fi
            fi
          else
            # Tag doesn't exist, create it normally
            echo "🆕 Creating new tag v${NEW_VERSION}"
            git tag -a "v${NEW_VERSION}" -m "Release v${SAFE_VERSION}" HEAD
            git push origin "v${NEW_VERSION}"

            # Verify tag creation succeeded
            FINAL_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "FAILED")
            if [ "${FINAL_COMMIT}" != "FAILED" ]; then
              echo "✅ Created new tag v${NEW_VERSION} for commit ${FINAL_COMMIT}"
            else
              echo "⚠️ Tag created but could not verify commit"
            fi
          fi

      - name: Create theme ZIP
        id: create-zip
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          ZIP_NAME="blocksy-child-v${{ steps.new-version.outputs.new-version }}.zip"
          THEME_FOLDER="blocksy-child"

          # Clean up any backup files created during the release process
          rm -f *.bak *.backup *.old CHANGELOG.md.bak 2>/dev/null || true

          # Create temporary directory structure for consistent folder naming
          mkdir -p "temp-build/${THEME_FOLDER}"

          # Copy theme files with comprehensive exclusions for production release
          # Based on BlazeCommerce production release analysis
          rsync -av --delete \
            --exclude='.git/' \
            --exclude='.github/' \
            --exclude='.augment/' \
            --exclude='.augmentignore' \
            --exclude='.gitignore' \
            --exclude='.gitattributes' \
            --exclude='.gitmodules' \
            --exclude='.zipignore' \
            --exclude='docs/' \
            --exclude='tests/' \
            --exclude='scripts/' \
            --exclude='bin/' \
            --exclude='node_modules/' \
            --exclude='vendor/' \
            --exclude='dist/' \
            --exclude='build/' \
            --exclude='assets/dist/' \
            --exclude='assets/build/' \
            --exclude='src/' \
            --exclude='coverage/' \
            --exclude='test-results/' \
            --exclude='test-releases/' \
            --exclude='releases/' \
            --exclude='agency_logo/' \
            --exclude='performance-optimizations/' \
            --exclude='security-fixes/' \
            --exclude='.husky/' \
            --exclude='.cache/' \
            --exclude='.tmp/' \
            --exclude='.sass-cache/' \
            --exclude='.parcel-cache/' \
            --exclude='.webpack/' \
            --exclude='.rollup.cache/' \
            --exclude='.phpunit.result.cache' \
            --exclude='.phpunit.cache/' \
            --exclude='.nyc_output/' \
            --exclude='.jest-cache/' \
            --exclude='screenshots/' \
            --exclude='test-screenshots/' \
            --exclude='visual-regression/' \
            --exclude='playwright-screenshots/' \
            --exclude='lighthouse-results/' \
            --exclude='__pycache__/' \
            --exclude='.patchwork-cache/' \
            --exclude='.vscode/' \
            --exclude='.idea/' \
            --exclude='.atom/' \
            --exclude='.history/' \
            --exclude='*.code-workspace' \
            --exclude='*.iml' \
            --exclude='*.ipr' \
            --exclude='*.iws' \
            --exclude='*.sublime-project' \
            --exclude='*.sublime-workspace' \
            --exclude='*.swp' \
            --exclude='*.swo' \
            --exclude='*.tmp' \
            --exclude='*.bak' \
            --exclude='*.backup' \
            --exclude='*.old' \
            --exclude='*.orig' \
            --exclude='*.rej' \
            --exclude='*.map' \
            --exclude='*.css.map' \
            --exclude='*.js.map' \
            --exclude='*.scss.map' \
            --exclude='*.less.map' \
            --exclude='*.sass.map' \
            --exclude='*.log' \
            --exclude='*.lock' \
            --exclude='*.lcov' \
            --exclude='*.pid' \
            --exclude='*.seed' \
            --exclude='*.pid.lock' \
            --exclude='*.py[cod]' \
            --exclude='*.so' \
            --exclude='*.egg-info/' \
            --exclude='*.egg' \
            --exclude='*.sh' \
            --exclude='*.bash' \
            --exclude='*.zsh' \
            --exclude='*.fish' \
            --exclude='*.ps1' \
            --exclude='*.bat' \
            --exclude='*.cmd' \
            --exclude='*.zip' \
            --exclude='*.tar.gz' \
            --exclude='*.tgz' \
            --exclude='*.sql' \
            --exclude='*.sqlite' \
            --exclude='*.db' \
            --exclude='*.psd' \
            --exclude='*.ai' \
            --exclude='*.sketch' \
            --exclude='*.fig' \
            --exclude='*.xd' \
            --exclude='*.indd' \
            --exclude='*.eps' \
            --exclude='*.key' \
            --exclude='*.pem' \
            --exclude='*.p12' \
            --exclude='*.pfx' \
            --exclude='.env*' \
            --exclude='!.env.example' \
            --exclude='!.env.sample' \
            --exclude='package.json' \
            --exclude='package-lock.json' \
            --exclude='composer.json' \
            --exclude='composer.lock' \
            --exclude='yarn.lock' \
            --exclude='pnpm-lock.yaml' \
            --exclude='bun.lockb' \
            --exclude='jest.config.js' \
            --exclude='playwright.config.js' \
            --exclude='stylelint.config.js' \
            --exclude='lighthouserc.js' \
            --exclude='webpack.config.js' \
            --exclude='rollup.config.js' \
            --exclude='vite.config.js' \
            --exclude='tsconfig.json' \
            --exclude='babel.config.js' \
            --exclude='.eslintrc.*' \
            --exclude='.prettierrc.*' \
            --exclude='.stylelintrc.*' \
            --exclude='phpunit.xml' \
            --exclude='phpunit-*.xml' \
            --exclude='patchwork.json' \
            --exclude='wp-config-local.php' \
            --exclude='wp-config-staging.php' \
            --exclude='wp-config-production.php' \
            --exclude='wp-config-development.php' \
            --exclude='wp-cli.local.yml' \
            --exclude='wp-cli.yml' \
            --exclude='local-config.php' \
            --exclude='local-development.php' \
            --exclude='.htpasswd' \
            --exclude='auth.json' \
            --exclude='.secrets' \
            --exclude='.htaccess.backup' \
            --exclude='.maintenance' \
            --exclude='.well-known/' \
            --exclude='wp-config-sample.php' \
            --exclude='readme.html' \
            --exclude='license.txt' \
            --exclude='temp-build/' \
            --exclude='*.md' \
            --exclude='.DS_Store' \
            --exclude='.AppleDouble' \
            --exclude='.LSOverride' \
            --exclude='._*' \
            --exclude='.DocumentRevisions-V100' \
            --exclude='.fseventsd' \
            --exclude='.Spotlight-V100' \
            --exclude='.TemporaryItems' \
            --exclude='.Trashes' \
            --exclude='.VolumeIcon.icns' \
            --exclude='.com.apple.timemachine.donotpresent' \
            --exclude='Thumbs.db' \
            --exclude='Thumbs.db:encryptable' \
            --exclude='ehthumbs.db' \
            --exclude='ehthumbs_vista.db' \
            --exclude='*.stackdump' \
            --exclude='[Dd]esktop.ini' \
            --exclude='$RECYCLE.BIN/' \
            --exclude='*.cab' \
            --exclude='*.msi' \
            --exclude='*.msix' \
            --exclude='*.msm' \
            --exclude='*.msp' \
            --exclude='*.lnk' \
            --exclude='.fuse_hidden*' \
            --exclude='.directory' \
            --exclude='.Trash-*' \
            --exclude='.nfs*' \
            --exclude='.eslintcache' \
            --exclude='.stylelintcache' \
            --exclude='.prettiercache' \
            --exclude='*-baseline.json' \
            --exclude='*-junit.xml' \
            --exclude='security-scan-results.json' \
            --exclude='vulnerability-report.json' \
            --exclude='lighthouse-report.html' \
            --exclude='lighthouse-report.json' \
            --exclude='k6-results.json' \
            --exclude='artillery-report.json' \
            --exclude='performance-report.json' \
            --exclude='load-test-*.json' \
            --exclude='stress-test-*.json' \
            --exclude='coverage-final.json' \
            --exclude='lcov-report/' \
            --exclude='clover.xml' \
            --exclude='cobertura.xml' \
            --exclude='junit.xml' \
            --exclude='test-summary.json' \
            --exclude='playwright-results.json' \
            --exclude='playwright-junit.xml' \
            --exclude='jest-results.json' \
            --exclude='lcov.info' \
            . "temp-build/${THEME_FOLDER}/"

          # Create ZIP from temp-build directory (includes the theme folder)
          cd temp-build
          zip -r "../${ZIP_NAME}" "${THEME_FOLDER}"
          cd ..

          # Clean up
          rm -rf temp-build

          echo "zip-name=${ZIP_NAME}" >> $GITHUB_OUTPUT
          echo "Created ZIP: ${ZIP_NAME}"
          echo "Theme folder in ZIP: ${THEME_FOLDER}"

          # Display ZIP contents summary for verification
          echo "ZIP contents summary:"
          unzip -l "${ZIP_NAME}" | head -20
          echo "..."
          unzip -l "${ZIP_NAME}" | tail -5

      - name: Validate production ZIP contents
        id: validate-zip
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        run: |
          ZIP_NAME="${{ steps.create-zip.outputs.zip-name }}"
          THEME_FOLDER="blocksy-child"

          echo "🔍 Validating production ZIP contents..."

          # Check for essential WordPress theme files
          ESSENTIAL_FILES=("style.css" "functions.php")
          MISSING_ESSENTIAL=()

          for file in "${ESSENTIAL_FILES[@]}"; do
            if ! unzip -l "${ZIP_NAME}" | grep -q "${THEME_FOLDER}/${file}"; then
              MISSING_ESSENTIAL+=("${file}")
            fi
          done

          if [[ ${#MISSING_ESSENTIAL[@]} -gt 0 ]]; then
            echo "❌ ERROR: Missing essential WordPress theme files:"
            for file in "${MISSING_ESSENTIAL[@]}"; do
              echo "  - ${file}"
            done
            exit 1
          fi

          # Check that development artifacts are properly excluded
          DEV_PATTERNS=(
            "node_modules/"
            "tests/"
            "scripts/"
            ".git/"
            "package.json"
            "composer.json"
            "*.config.js"
            "*.md"
            ".github/"
            "docs/"
            "vendor/"
            ".vscode/"
            ".idea/"
            "coverage/"
            "*.log"
            "*.lock"
            "*.bak"
            ".env"
            "__pycache__/"
            "agency_logo/"
          )

          FOUND_DEV_FILES=()
          for pattern in "${DEV_PATTERNS[@]}"; do
            if unzip -l "${ZIP_NAME}" | grep -q "${pattern}"; then
              FOUND_DEV_FILES+=("${pattern}")
            fi
          done

          if [[ ${#FOUND_DEV_FILES[@]} -gt 0 ]]; then
            echo "⚠️ WARNING: Found development files in production ZIP:"
            for file in "${FOUND_DEV_FILES[@]}"; do
              echo "  - ${file}"
            done
            echo "These files should be excluded from production releases"
            # Don't fail the build, but warn about it
          fi

          # Get ZIP file size for reporting
          ZIP_SIZE=$(du -h "${ZIP_NAME}" | cut -f1)
          FILE_COUNT=$(unzip -l "${ZIP_NAME}" | tail -1 | awk '{print $2}')

          echo "✅ ZIP validation completed:"
          echo "  - Size: ${ZIP_SIZE}"
          echo "  - Files: ${FILE_COUNT}"
          echo "  - Essential files: ✓ Present"
          echo "  - Development artifacts: $([ ${#FOUND_DEV_FILES[@]} -eq 0 ] && echo "✓ Excluded" || echo "⚠️ Some found")"

      - name: Check and clean up existing release
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        env:
          GITHUB_TOKEN: ${{ steps.token-fallback.outputs.token }}
        run: |
          NEW_VERSION="${{ steps.new-version.outputs.new-version }}"

          # Input validation for security
          if [ -z "${NEW_VERSION}" ]; then
            echo "❌ Error: NEW_VERSION is empty"
            exit 1
          fi

          # Validate version format to prevent command injection
          if ! echo "${NEW_VERSION}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "❌ Error: Invalid version format: ${NEW_VERSION}"
            exit 1
          fi

          echo "🔍 Checking for existing release v${NEW_VERSION}"

          # Check if release already exists with proper error handling
          RELEASE_ID=$(gh api "repos/${{ github.repository }}/releases/tags/v${NEW_VERSION}" --jq '.id' 2>/dev/null || echo "")
          if [ -n "${RELEASE_ID}" ]; then
            echo "⚠️ Release v${NEW_VERSION} already exists (ID: ${RELEASE_ID})"
            echo "Deleting existing release to recreate it with updated information"

            # Attempt to delete with error handling
            if gh api -X DELETE "repos/${{ github.repository }}/releases/${RELEASE_ID}" 2>/dev/null; then
              echo "✅ Successfully deleted existing release v${NEW_VERSION}"
            else
              echo "⚠️ Failed to delete existing release, but continuing (may be already deleted)"
            fi
          else
            echo "✅ No existing release found for v${NEW_VERSION}"
          fi

      - name: Create GitHub Release
        id: create_release
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ steps.token-fallback.outputs.token }}
        with:
          tag_name: v${{ steps.new-version.outputs.new-version }}
          release_name: Release v${{ steps.new-version.outputs.new-version }}
          body_path: RELEASE_CHANGELOG.md
          draft: false
          prerelease: false

      - name: Upload ZIP to Release
        if: steps.check-non-functional.outputs.non-functional-only != 'true'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ steps.token-fallback.outputs.token }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./${{ steps.create-zip.outputs.zip-name }}
          asset_name: ${{ steps.create-zip.outputs.zip-name }}
          asset_content_type: application/zip

      - name: Notify on success
        if: success()
        run: |
          echo "✅ Successfully released version ${{ steps.new-version.outputs.new-version }}"
          echo "📦 ZIP file: ${{ steps.create-zip.outputs.zip-name }}"
          echo "🔗 Release URL: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.new-version.outputs.new-version }}"

      - name: Notify on failure
        if: failure()
        run: |
          echo "❌ Release workflow failed"
          echo "Please check the logs and fix any issues"
          if [ "${{ steps.token-fallback.outputs.using-fallback }}" = "true" ]; then
            echo "⚠️ Note: Workflow used GITHUB_TOKEN fallback due to GitHub App token failure"
            echo "Consider checking GitHub App configuration for better functionality"
          fi
          exit 1

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: release
    if: failure() && needs.release.outputs.new-release-version != ''

    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        continue-on-error: true
        with:
          app-id: ${{ secrets.BLAZECOMMERCE_BOT_APP_ID }}
          private-key: ${{ secrets.BLAZECOMMERCE_BOT_PRIVATE_KEY }}

      - name: Fallback to GITHUB_TOKEN if App Token fails
        id: token-fallback
        run: |
          if [ "${{ steps.app-token.outcome }}" = "failure" ]; then
            echo "⚠️ GitHub App token generation failed, falling back to GITHUB_TOKEN"
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
          else
            echo "✅ GitHub App token generated successfully"
            echo "token=${{ steps.app-token.outputs.token }}" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.token-fallback.outputs.token }}

      - name: Configure Git
        run: |
          git config --global user.name "BlazeCommerce Automation Bot"
          git config --global user.email "automation@blazecommerce.io"
          git remote set-url origin https://x-access-token:${{ steps.token-fallback.outputs.token }}@github.com/${{ github.repository }}.git

      - name: Rollback tag and release
        env:
          GITHUB_TOKEN: ${{ steps.token-fallback.outputs.token }}
        run: |
          VERSION="${{ needs.release.outputs.new-release-version }}"
          if [ -n "${VERSION}" ]; then
            echo "🔄 Rolling back version ${VERSION}"

            # Validate version format for security
            if ! echo "${VERSION}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "❌ Error: Invalid version format for rollback: ${VERSION}"
              exit 1
            fi

            # Delete the tag if it exists (with proper regex escaping)
            if git tag -l | grep -q "^v${VERSION}\$"; then
              echo "🗑️ Deleting tag v${VERSION}"
              if git tag -d "v${VERSION}" 2>/dev/null; then
                echo "✅ Local tag deleted successfully"
              else
                echo "⚠️ Failed to delete local tag (may not exist locally)"
              fi

              if git push --delete origin "v${VERSION}" 2>/dev/null; then
                echo "✅ Remote tag deleted successfully"
              else
                echo "⚠️ Failed to delete remote tag (may not exist remotely)"
              fi
            else
              echo "ℹ️ No tag v${VERSION} found to delete"
            fi

            # Delete the release if it exists
            echo "🔍 Checking for existing release v${VERSION}"
            RELEASE_ID=$(gh api "repos/${{ github.repository }}/releases/tags/v${VERSION}" --jq '.id' 2>/dev/null || echo "")
            if [ -n "${RELEASE_ID}" ]; then
              echo "🗑️ Deleting release v${VERSION} (ID: ${RELEASE_ID})"
              if gh api -X DELETE "repos/${{ github.repository }}/releases/${RELEASE_ID}" 2>/dev/null; then
                echo "✅ Release deleted successfully"
              else
                echo "⚠️ Failed to delete release (may be already deleted)"
              fi
            else
              echo "ℹ️ No release found for v${VERSION}"
            fi

            echo "✅ Rollback completed for version ${VERSION}"
          else
            echo "ℹ️ No version specified for rollback, skipping"
          fi
